@include std::io

mod std => {
    mod core => {
        mod drop => {
            interface Droppable T => {
                drop(): void;
            }

            interface NonDroppable T => {}
        }
        mod iter => {
            interface Iterator T => {
                type Output;
                has_next(): bool;
                next(): Output;
            }

            interface Iterable T => {
                type Iter impl Iterator;
                to_iter(): Iter;
            }
        }
    }

    mod opt => {
        impl <T> std::core::iter::Iterable for Option<T> => {
            type Iter => OptionIter<T>;

            public to_iter(): Iter => {
                @todo;
            }
        }

        impl <T> std::core::iter::Iterator for OptionIter<T> => {
            type Output => T;

            public has_next(): bool => {
                @todo;
            }

            public next(): Output => {
                @todo;
            }
        }

        class <T> Option => {
            private item: T*;

            public Option(x: T) => {
                @todo;
            }

            public Option() => {
                @todo;
            }

            public unwrap(): T => {
                @todo;
            }
        }

        class <T> OptionIter => {
            public OptionIter(from: Option<T>) => {
                @todo;
            }
        }
    }

    mod vec => {
        class <T> Vec => {
            private items: T*;
            private count: u32;
            private capacity: u32;

            public Vec() => {
                @todo;
            }

            public Vec(with_capacity: u32) => {
                @todo;
            }


            public get(i: u32): opt::Option<T> => {
                @todo;
            }

        }

        class <T> VecIter => {
            public VecIter(from: Vec<T>) => {
                @todo;
            }
        }

        impl <T> std::core::iter::Iterable for Vec<T> => {
            type Iter => VecIter<T>;

            public to_iter(): Iter => {
                @todo();
            }
        }

        impl <T> std::core::iter::Iterator for VecIter<T> => {
            type Output => T;

            public has_next(): bool => {
                @todo;
            }

            public next(): Output => {
                @todo;
            }
        }

        impl <T impl drop::Droppable> Vec<T> => {
            public drop(): void => {
                for x in self => {
                    x::drop();
                }
                free(self::data);
                self::capacity => 0;
                self::count => 0;
            }
        }

        use std::core::drop;

        impl <T impl drop::NonDroppable> Vec<T> => {
            public drop(): void => {
                free(self::data);
                self::capacity => 0;
                self::count => 0;
            }
        }

        impl <T> drop::Droppable for Vec<T> => {}
    }

    mod str => {
        class String => {
            private data: vec::Vec<u8>;
        }
    }
}

let test(): (std::vec::Vec<std::str::String>, std::opt::Option<u32>) => {
    @todo;
}

mod a => {
    let fn(): void => {
        printf("Hello, World !\n");
    }
}

let test_alias():  Vector<int> => { @todo; }

use vec => std::vec;
use Vector => vec::Vec;
use std::str::String;

let x(): String => { @todo; }

let main(): int => {
    let instance => @as MyClass(69, 420);
    instance::method();
    printf("Hello, World !\n");
    return 0;
}

class MyClass => {
    private x: int;
    private y: int;

    public MyClass(x: int, y: int) => {
        self::x => x;
        self::y => y;
    }

    public method(): void => {
        printf("self::x = %d, self::y = %d\n", self::x, self::y);
    }
}
