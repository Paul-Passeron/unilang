@include std::io

mod std => {
    mod iter => {
        interface Iterator T => {
            type Output;
            has_next(): bool;
            next(): Output;
        }

        interface Iterable T => {
            type Iter impl Iterator;
            to_iter(): Iter;
        }
    }

    mod opt => {
        impl <T> iter::Iterable for Option<T> => {
            type Iter => OptionIter<T>;

            public to_iter(): Iter => {
                @todo;
            }
        }

        impl <T> iter::Iterator for OptionIter<T> => {
            type Output => T;

            public has_next(): bool => {
                @todo;
            }

            public next(): Output => {
                @todo;
            }
        }

        class <T> Option => {
            private item: T*;

            public Option(x: T) => {
                @todo;
            }

            public Option() => {
                @todo;
            }

            public unwrap(): T => {
                @todo;
            }
        }

        class <T> OptionIter => {
            public OptionIter(from: Option<T>) => {
                @todo;
            }
        }
    }

    mod vec => {
        class <T> Vec => {
            private items: T*;
            private count: u32;
            private capacity: u32;

            public Vec() => {
                @todo;
            }

            public Vec(with_capacity: u32) => {
                @todo;
            }


            public get(i: u32): opt::Option<T> => {
                @todo;
            }

        }

        class <T> VecIter => {
            public VecIter(from: Vec<T>) => {
                @todo;
            }
        }

        impl <T> iter::Iterable for Vec<T> => {
            type Iter => VecIter<T>;

            public to_iter(): Iter => {
                @todo();
            }
        }

        impl <T> iter::Iterator for VecIter<T> => {
            type Output => T;

            public has_next(): bool => {
                @todo;
            }

            public next(): Output => {
                @todo;
            }
        }
    }

    mod str => {
        class String => {
            private data: vec::Vec<u8>;
        }
    }
}

let test(): (std::vec::Vec<std::str::String>, std::opt::Option<u32>) => {
    @todo;
}

mod a => {
    let fn(): void => {
        printf("Hello, World !\n");
    }
}


let other():  Vector<int> => { @todo; }
let other1(): Vector<int> => { @todo; }
let other3(): Vector<int> => { @todo; }
let other4(): Vector<int> => { @todo; }
let other5(): Vector<int> => { @todo; }
let other6(): Vector<int> => { @todo; }
let other7(): std::str::String =>  { @todo; }

type Vector => std::vec::Vec;

let main(): int => {
    printf("Hello, World !\n");
    return 0;
}



class MyClass => {
    private x: int;
    private y: int;

    public MyClass(x: int, y: int) => {
        self::x => x;
        self::y => y;
    }

    public method(): void => {
        printf("self::x = %d, self::y = %d\n", self::x, self::y);
    }
}
