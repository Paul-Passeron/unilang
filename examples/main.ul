@include std::io

mod std => {
    mod iter => {
        interface Iterator T => {
            type Output;
            has_next(): bool;
            next(): Output;
        }

        interface Iterable T => {
            type Iter impl Iterator;
            to_iter(): Iter;
        }
    }

    mod opt => {
        impl <T> iter::Iterable for Option<T> => {
            type Iter => OptionIter<T>;

            public to_iter(): Iter => {
                @todo;
            }
        }

        impl <T> iter::Iterator for OptionIter<T> => {
            type Output => T;

            public has_next(): bool => {
                @todo;
            }

            public next(): Output => {
                @todo;
            }
        }

        class <T> Option => {
            private item: T*;

            public Option(x: T) => {
                @todo;
            }

            public Option() => {
                @todo;
            }

            public unwrap(): T => {
                @todo;
            }
        }

        class <T> OptionIter => {
            public OptionIter(from: Option<T>) => {
                @todo;
            }
        }
    }

    mod vec => {
        class <T> Vec => {
            private items: T*;
            private count: u32;
            private capacity: u32;

            public Vec() => {
                @todo;
            }

            public Vec(with_capacity: u32) => {
                @todo;
            }


            public get(i: u32): opt::Option<T> => {
                @todo;
            }

        }

        class <T> VecIter => {
            public VecIter(from: Vec<T>) => {
                @todo;
            }
        }

        impl <T> iter::Iterable for Vec<T> => {
            type Iter => VecIter<T>;

            public to_iter(): Iter => {
                @todo();
            }
        }

        impl <T> iter::Iterator for VecIter<T> => {
            type Output => T;

            public has_next(): bool => {
                @todo;
            }

            public next(): Output => {
                @todo;
            }
        }
    }

    mod str => {
        class String => {
            private data: vec::Vec<u8>;
        }
    }
}

let test(): (std::vec::Vec<std::str::String>, std::opt::Option<u32>) => {
    @todo;
}

mod a => {
    let fn(): void => {
        printf("Hello, World !\n");
    }
}

let other():  std::vec::Vec<int> => {}
let other1(): std::vec::Vec<int> => {}
let other3(): std::vec::Vec<int> => {}

let main(): int => {
    let x: int => 7;
    let c: Vec<int>;
    a::fn();
    return 0;
}
