@include std::io

class <T> A => {
    public x: T;
    public A(x: T) => {
        self::x => x;
    }
}

class B => {
    public padding: int;
    public B() => {
        self::padding => 0;
    }
}

impl A<int> => {
    public from_int(y: int): int => {
        return self::x + y;
    }
}

impl FromB for A<B> => {
    public from_B(y: int): int => {
        return y * y;
    }
}

interface FromB T => {
    from_B(x: int): int;
}

class <T impl FromB> C => {
    public C() => {}
    public call_from_B(x: T): int => {
        return x::from_B(99);
    }
}

let main(): int => {
    let i => (@as A<int>(45))::from_int(24);
    let j => (@as A<B>(@as B()))::from_B(24);
    let k => (@as C<A<B>>())::call_from_B(@as A<B>(@as B()));
    // TODO: enforce interface constraints so that the next line fails at compile
    // time not because "No method named `from_B` for type `A<i32>`" but because
    // "type `A<i32>` does not implement FromB interface needed to specialize `C<A<i32>>`"
    // let l => (@as C<A<int>>())::call_from_B(@as A<int>(5));
    printf("i = %d\n", i);
    printf("j = %d\n", j);
    printf("k = %d\n", k);
    // printf("l = %d\n", l);

    return 0;
}
